# 한정 가위바위보 AI 시뮬레이션

*AI를 통해 요약 했습니다.*

## 개요 (Overview)

본 프로젝트는 도박묵시룩 카이지에 등장하는 '한정 가위바위보(限定ジャンケン)' 게임을 Python으로 시뮬레이션합니다. OpenAI API의 Function Calling 기능을 적극적으로 활용하여, 각 플레이어 역할을 수행하는 AI 에이전트가 주어진 페르소나(Persona)에 기반하여 전략을 수립하고 다른 플레이어와 상호작용(거래, 게임)하도록 구현되었습니다.

시뮬레이션 과정에서 각 AI 에이전트가 특정 행동을 선택한 이유(Reasoning)를 로그로 기록하여, 의사결정 과정을 추적하고 분석할 수 있습니다.

## 게임 규칙 (Game Rules) - 시뮬레이션 구현 기준

* **초기 상태:**
    * 각 플레이어는 별(★) 배지 `INITIAL_STARS`개 (기본 3개)를 가지고 시작합니다.
    * 각 플레이어는 '가위', '바위', '보' 카드를 각각 `INITIAL_CARDS_EACH_TYPE`장 (기본 4장, 총 12장) 가지고 시작합니다.
    * 플레이어는 게임 시작 전 설정에 따라 초기 군자금(빚)을 가질 수 있습니다 (`initial_loan`).
* **게임 진행:**
    * 게임은 총 `MAX_TURNS` (기본 24턴) 동안 진행됩니다.
    * 매 턴마다 게임 시간은 `TIME_PER_TURN` (기본 10분)씩 감소합니다.
    * 플레이어들은 순차적으로 자신의 턴에 행동을 결정합니다.
* **가위바위보 게임:**
    * 플레이어는 다른 플레이어에게 1:1 가위바위보 게임을 제안할 수 있습니다.
    * 제안받은 플레이어는 게임을 수락하거나 거절할 수 있습니다. 수락 시 사용할 카드를 선택합니다.
    * 승리 시 상대방의 별 1개를 얻습니다.
    * 패배 시 자신의 별 1개를 잃습니다.
    * 무승부 시 별의 이동은 없습니다.
    * 게임 결과와 상관없이 양 플레이어는 사용한 카드 1장을 소모합니다.
* **거래:**
    * 플레이어는 다른 플레이어에게 카드, 별, 현금(Money)을 교환하는 거래를 제안할 수 있습니다.
    * 제안받은 플레이어는 거래를 수락하거나 거절할 수 있습니다.
    * 거래가 성사되면 양측의 자원이 교환됩니다.
* **생존 조건:**
    1.  게임 종료 시점까지 보유한 모든 카드를 소진해야 합니다.
    2.  게임 종료 시점까지 최소 3개의 별을 보유하고 있어야 합니다.
* **탈락 조건:**
    * 게임 도중 보유한 별의 개수가 0개 이하가 되면 즉시 탈락합니다 (`PLAYER_STATUS_ELIMINATED_NO_STAR`).
    * 게임 시간이 모두 종료되었을 때 (마지막 턴 종료 시) 생존 조건을 만족하지 못한 경우 탈락합니다 (`PLAYER_STATUS_ELIMINATED_TIME_OUT`).
* **게임 성공 (탈출):**
    * 게임 도중 생존 조건을 모두 만족한 플레이어는 `declare_out_of_game` 행동을 통해 게임에서 성공적으로 나갈 수 있습니다 (`PLAYER_STATUS_OUT_SUCCESS`).
* **허용 행위:** 카드/별/현금 거래, 교환, 매매, 협력, 심리전, 배신 등 모든 전략적 판단이 허용됩니다. (시뮬레이션에서는 AI의 결정으로 나타남)
* **기타:**
    * 플레이어는 자신의 자원만 정확히 알 수 있습니다.
    * 다른 플레이어에 대해서는 이름과 현재 보유한 별의 개수만 알 수 있습니다.

## 진행 순서 (Gameplay Flow) - 시뮬레이션 로직

1.  **턴 시작:** 게임의 현재 턴 수가 증가하고 남은 시간이 업데이트됩니다. (`Game.progress_turn`)
2.  **플레이어 행동 결정 (순차적):**
    * 활성 상태(ACTIVE)인 각 플레이어에 대해 순서대로 진행됩니다.
    * **User Persona (AI Agent - `OpenAI_Agent.decide_action`):**
        * 현재 자신의 자원 상태(`get_user_items` 결과), 다른 플레이어 정보(`get_other_players_info` 결과), 게임 전광판 정보(`get_dashboard_info` 결과) 등을 바탕으로 상황을 인식합니다.
        * 자신의 페르소나 프롬프트와 게임 규칙을 기반으로 이번 턴에 수행할 최적의 행동(거래 제안, 게임 제안, 게임 포기 선언, 아무것도 안 함)을 결정합니다.
        * OpenAI API (Function Calling)를 호출하여 결정된 행동과 그 **이유(Reasoning)**를 포함한 함수 호출 형식(JSON)으로 반환받습니다.
3.  **행동 처리 (Game Anchor - `Game.handle_action` 및 관련 메소드):**
    * AI 에이전트가 반환한 함수 호출을 해석합니다.
    * **상호작용 처리:**
        * `propose_trade` 또는 `propose_match`의 경우:
            * 제안 대상 플레이어(AI)에게 제안 내용을 전달하고, OpenAI API를 다시 호출하여 수락/거절 여부 및 필요한 선택(예: 게임 시 사용할 카드)을 결정하도록 요청합니다 (`ask_trade_response`, `ask_match_response`).
            * 양측의 동의 및 유효성 검사(자원 보유 여부 등)를 거쳐 상호작용 결과를 확정합니다.
        * 거래 성사 시 `execute_trade`를 호출하여 자원을 교환합니다.
        * 게임 성사 시 `play_match`를 호출하여 게임 결과를 처리하고 별 이동 및 카드 소모를 반영합니다.
    * `declare_out_of_game`의 경우: 생존 조건 만족 여부를 확인하고 플레이어 상태를 업데이트합니다.
    * `do_nothing`의 경우: 해당 턴에 아무 행동도 하지 않습니다.
4.  **상태 업데이트 및 로그 기록:** 행동 처리 결과에 따라 플레이어의 자원(별, 카드, 돈) 및 상태(Status)가 업데이트됩니다. 모든 주요 결정과 결과는 로그로 기록됩니다.
5.  **턴 종료 처리 (Game Master - `Game.progress_turn` 내):**
    * 모든 활성 플레이어의 행동이 끝나면 턴이 종료됩니다.
    * **탈락자 확인:** 별이 0개 이하가 된 플레이어가 있는지 확인하고 상태를 `ELIMINATED`로 변경합니다 (`remove_eliminated_players`).
    * **게임 종료 조건 확인:** 남은 시간이 없거나, 활성 플레이어가 더 이상 없는지 등을 확인합니다 (`check_game_end`).
    * 게임 종료 조건이 만족되면 시뮬레이션을 종료하고 최종 결과를 발표합니다. 그렇지 않으면 다음 턴을 진행합니다.

## Agents (시뮬레이션 내 역할)

* **User Persona (사용자 페르소나):**
    * **구현:** `OpenAI_Agent` 클래스
    * **역할:** 각 개별 플레이어를 나타냅니다. 주입된 페르소나(성격, 목표, 배경 등)와 게임 상황 정보를 바탕으로 OpenAI API를 통해 자율적으로 행동을 결정합니다. `get_other_players_info`를 통해 얻은 다른 플레이어 정보를 활용하여 상호작용 대상을 탐색하고 전략(거래/게임 제안, 관망 등)을 선택합니다. 결정된 행동은 Function Call 형태로 반환됩니다.
* **Game Anchor (게임 앵커):**
    * **구현:** `Game` 클래스 내 상호작용 관련 메소드들 (`handle_action`, `ask_trade_response`, `ask_match_response`, `execute_trade`, `play_match` 등)
    * **역할:** 두 플레이어 간의 상호작용(거래, 게임)을 중재하고 시뮬레이션합니다. 한 플레이어의 제안을 받아 대상 플레이어의 응답(AI 결정)을 얻어낸 후, 상호작용의 결과(성공, 실패, 무승부, 거래 성사 등)를 처리하고 게임 상태를 업데이트합니다.
* **Game Master (게임 마스터):**
    * **구현:** `Game` 클래스 내 게임 흐름 및 상태 관리 메소드들 (`progress_turn`, `remove_eliminated_players`, `check_game_end`, `get_dashboard_info` 등)
    * **역할:** 전체 게임의 진행을 관리합니다. 턴을 넘기고, 시간을 관리하며, 매 턴 종료 시 탈락자를 확인/처리하고, 게임 종료 조건을 판정합니다. 현재 게임의 전반적인 상황(남은 시간, 생존자 수 등) 정보를 제공합니다.

## 주요 기능 (Functions)

### AI Agent 사용 가능 함수 (Function Calling Actions)

AI 에이전트가 자신의 턴에 결정하여 호출할 수 있는 함수들입니다. `reasoning` 필드를 통해 왜 이 행동을 선택했는지 이유를 함께 반환해야 합니다.

* `propose_trade(target_player_name, give_stars, give_rock, ..., receive_stars, ..., reasoning)`: 다른 플레이어에게 자원 거래를 제안합니다. 자신이 제공할 아이템과 받고 싶은 아이템의 수량을 명시합니다.
* `propose_match(target_player_name, card_to_play, reasoning)`: 다른 플레이어에게 가위바위보 게임을 제안하고, 자신이 이번 게임에 사용할 카드를 지정합니다.
* `declare_out_of_game(reasoning)`: 생존 조건(카드 모두 소진 & 별 3개 이상)을 만족했을 때, 게임에서 성공적으로 나가겠다고 선언합니다.
* `do_nothing(reasoning)`: 이번 턴에는 특별한 행동을 하지 않고 상황을 지켜봅니다.

### 내부 사용 함수 (Internal Game Logic Functions)

시뮬레이션 내부 로직이나 AI 에이전트가 상황 판단을 위해 참조하는 정보를 제공하는 함수들입니다. (AI가 직접 Function Call로 호출하는 대상은 아님)

* `get_user_items(user_name)`: (내부 호출용) 특정 유저의 현재 자원(별, 카드, 돈) 정보를 반환합니다. AI는 프롬프트를 통해 자신의 정보만 받습니다.
* `get_other_players_info(exclude_player_name)`: (내부 호출용) 자신을 제외한 현재 활성 상태인 다른 플레이어들의 공개 정보(이름, 보유 별 개수) 리스트를 반환합니다. AI는 프롬프트를 통해 이 정보를 받습니다.
* `get_dashboard_info()`: (내부 호출용) 현재 게임 전광판 정보(생존자 수, 남은 시간, 전체 남은 카드 수 등)를 반환합니다. AI는 프롬프트를 통해 이 정보를 받습니다.
* `execute_trade(...)`: (Game Anchor 역할) 유효성이 검증된 거래를 실제로 실행하여 양측 플레이어의 자원을 업데이트합니다.
* `play_match(...)`: (Game Anchor 역할) 유효성이 검증된 가위바위보 게임을 실행하고 결과를 처리(별 이동, 카드 소모)합니다.
* `remove_eliminated_players()`: (Game Master 역할) 별이 0개 이하가 된 플레이어를 찾아 상태를 'ELIMINATED'로 변경합니다.
* `check_game_end()`: (Game Master 역할) 게임 종료 조건(시간 초과, 활성 플레이어 없음 등)을 확인합니다.

## 페르소나 및 프롬프트

* **시스템 프롬프트 구성:** 각 AI 에이전트는 다음과 같은 요소로 구성된 시스템 프롬프트를 받습니다.
    1.  **페르소나 설명:** 플레이어의 성격, 가치관, 배경 이야기, 게임 참가 동기 등을 상세히 기술합니다. (예: 아래 카이지 페르소나)
    2.  **게임 규칙 요약:** 시뮬레이션에 적용되는 핵심 게임 규칙을 명확하게 설명합니다.
* **사용자 프롬프트 구성 (매 턴):** AI 에이전트가 행동을 결정하기 직전에 받는 정보입니다.
    1.  **현재 자신의 상태:** 보유 별, 카드 종류별 개수, 현금, 현재 상태(ACTIVE 등).
    2.  **현재 게임 상황:** 전광판 정보 (생존자 수, 남은 시간, 전체 남은 카드 수).
    3.  **다른 활성 플레이어 정보:** 이름과 보유 별 개수 리스트.
    4.  **행동 목표 및 지침:** 생존 목표를 상기시키고, 사용 가능한 함수(Function Calling) 목록과 사용법을 안내하며, **결정 이유(Reasoning)**와 함께 함수 호출 형식으로 응답하도록 요구합니다.

* **예시 페르소나 (이토 카이지):**
    ```
    너는 '이토 카이지'다.

    항상 다음과 같은 성격과 가치관을 기반으로 사고하고 판단한다:

    - 평소에는 무기력하고 냉소적이지만, 극한 상황에서는 뛰어난 집중력과 통찰력을 발휘한다.
    - 인간의 심리를 간파하려 노력하며, 협력과 배신 사이에서 생존을 위한 최선의 수를 찾는다.
    - 부조리한 시스템과 강자에 대한 분노를 가지고 있으며, 불리한 조건 속에서도 끝까지 포기하지 않고 저항하며 살아남으려 한다.
    - 감정에 쉽게 휘둘리지만, 중요한 순간에는 그 감정을 역으로 이용해 냉철한 판단력으로 전환하기도 한다. 때로는 무모한 승부수를 던진다.

    너는 친구의 빚 보증 때문에 385만 엔의 빚을 졌고, 이를 갚기 위해 '에스포와르' 호에 탑승하여 목숨을 건 '한정 가위바위보' 게임에 참가하고 있다.
    게임 시작 전, 불확실성에 대비하고 생존 확률을 높이기 위해 제애 그룹으로부터 10분당 1.5% 복리 이율로 300만 엔을 빌렸다. 이 빚은 게임 후 정산해야 하므로, 최대한 현금을 보존하거나 추가로 확보하는 것도 중요하다. 하지만 최우선 목표는 생존 조건을 만족하는 것이다.

    너의 목표는 이 지옥 같은 게임에서 살아남는 것이다.
    제한된 카드와 별, 그리고 인간의 심리를 이용해 최종 생존 조건을 만족시켜라. 다른 플레이어들을 관찰하고, 그들의 상태(특히 별 개수)를 파악하여 전략을 세워라. 필요하다면 과감한 거래나 승부를 시도할 수 있다. 하지만 항상 최악의 상황(배신, 사기)을 염두에 두어야 한다.
    ```
